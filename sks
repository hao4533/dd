//bfs
#include <stdio.h>
#define MAX 100

typedef struct {
    int A[MAX][MAX];
    int n;            
} Graph;
void init_graph(Graph *G, int n) {
    G->n = n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            G->A[i][j] = 0;
        }
    }
}
void add_edge(Graph *G, int u, int v) {
    G->A[u][v] = 1;
    G->A[v][u] = 1;
}
typedef struct {
    int data[MAX];
    int front, rear;
} Queue;
void init_queue(Queue *q) {
    q->front = -1;
    q->rear = -1;
}
int is_empty(Queue *q) {
    return q->front == -1;
}
void enqueue(Queue *q, int v) {
    if (q->rear == MAX - 1) {
        printf("Hàng đợi đầy\n");
        return;
    }
    if (q->front == -1) q->front = 0;
    q->rear++;
    q->data[q->rear] = v;
}
int dequeue(Queue *q) {
    if (is_empty(q)) {
        printf("Hàng đợi rỗng\n");
        return -1;
    }
    int x = q->data[q->front];
    if (q->front >= q->rear) {
        q->front = -1;
        q->rear = -1;
    } else {
        q->front++;
    }
    return x;
}
void bfs(Graph *G, int x) {
    int C[MAX] = {0};
    Queue q;
    init_queue(&q);
    C[x] = 1;
    enqueue(&q, x);

    while (!is_empty(&q)) {
        int u = dequeue(&q);
        printf("%d\n", u);
        for (int i = 1; i <= G->n; i++) {
            if (G->A[u][i] && !C[i]) {
                C[i] = 1;
                enqueue(&q, i);
            }
        }
    }
}
int main() {
    Graph G;
    int n, m, u, v, s;
    scanf("%d %d", &n, &m);
    init_graph(&G, n);

    for (int i = 0; i < m; i++) {
        scanf("%d %d", &u, &v);
        add_edge(&G, u, v);
    }

    scanf("%d", &s);
    bfs(&G, s);

    return 0;
}

//bfs đầy đủ
#include <stdio.h>
#include <stdlib.h>
#define MAX 100
typedef struct {
    int A[MAX][MAX];
    int n;            
} Graph;
void init_graph(Graph *G, int n) {
    G->n = n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            G->A[i][j] = 0;
        }
    }
}
void add_edge(Graph *G, int u, int v) {
    G->A[u][v] = 1;
}
typedef struct {
    int data[MAX];
    int front, rear;
} Queue;
void init_queue(Queue *q) {
    q->front = -1;
    q->rear = -1;
}
int is_empty(Queue *q) {
    return q->front == -1;
}
void enqueue(Queue *q, int x) {
    if (q->rear == MAX - 1) {
        printf("Hàng đợi đầy\n");
        return;
    }
    if (q->front == -1) q->front = 0;
    q->rear++;
    q->data[q->rear] = x;
}

int dequeue(Queue *q) {
    if (is_empty(q)) {
        printf("Hàng đợi rỗng\n");
        return -1;
    }
    int u = q->data[q->front];
    if (q->front >= q->rear) {
        q->front = -1;
        q->rear = -1;
    } else {
        q->front++;
    }
    return u;
}
void bfs(Graph *G, int u, int mark[]) {
    Queue q;
    init_queue(&q);
    mark[u] = 1;
    enqueue(&q, u);
    while (!is_empty(&q)) {
        int x = dequeue(&q);
        printf("%d\n", x);

        for (int i = 1; i <= G->n; i++) {
            if (G->A[x][i] && !mark[i]) {
                mark[i] = 1;
                enqueue(&q, i);
            }
        }
    }
}
int main() {
    Graph G;
    int n, m, u, v;
    scanf("%d %d", &n, &m);
    init_graph(&G, n);
    for (int i = 0; i < m; i++) {
        scanf("%d %d", &u, &v);
        add_edge(&G, u, v);
    }
  int mark[MAX] = {0};
   for (int i = 1; i <= n; i++) {
        if (!mark[i]) {
            bfs(&G, i, mark);
        }
    }
    return 0;
}


//dfs
#include <stdio.h>
#include <stdlib.h>
#define MAXN 100
int n, m;
int A[MAXN][MAXN];  
int mark[MAXN];  
void dfs(int u) {
    printf("%d\n", u);  
    mark[u] = 1;  
    for (int v = 1; v <= n; v++) {
        if (A[u][v] == 1 && !mark[v]) {
            dfs(v);
        }
    }
}
int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            A[i][j] = 0;
        }
    }
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        A[u][v] = 1;
        A[v][u] = 1;  
    }
    for (int i = 1; i <= n; i++) {
        mark[i] = 0;
    }
    int s;
    scanf("%d", &s);
    dfs(s);   
    return 0;
}

//dfs đầy đủ
#include <stdio.h>
#include <stdlib.h>
#define MAX_N 1000
int adj[MAX_N][MAX_N]; 
int visited[MAX_N]; 
void dfs(int u, int n) {
    printf("%d\n", u);
    visited[u] = 1;
    for (int v = 1; v <= n; v++) {
        if (adj[u][v] == 1 && !visited[v]) {
            dfs(v, n);
        }
    }
}
int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            adj[i][j] = 0; 
        }
    }
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        adj[u][v] = 1;
    }
    for (int i = 1; i <= n; i++) {
        visited[i] = 0;
    }
    dfs(1, n);
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            dfs(i, n);
        }
    }
    return 0;
}


//cây
#include <stdio.h>
#include <stdbool.h>
#define maxv 50
#define idx 100
int n,m;
typedef int Vertices;
typedef struct{
    int matrix[maxv][maxv];
    Vertices n;
}Graph;
typedef struct{
    int data[idx];
    int size;
}List;
typedef struct{
    int front;
    int rear;
    int data[maxv];
}Queue;
void makenullQueue(Queue *q){
    q->front=0;
    q->rear=-1;
}
bool emptyQueue(Queue *q){
    return q->front > q->rear;
}
void pushQueue(Queue *q, int element){
    q->rear++;
    q->data[q->rear]=element;
}
int getQueue(Queue *q){
    return q->data[q->front];
}
void plusFront(Queue *q){
    q->front++;
}
void makenullList(List *l){
    l->size=0;
}
bool emptyList(List *l){
    return l->size==0;
}
void pushList(List *l, int element){
    l->data[l->size]=element;
    l->size++;
}
int getList(List *l, int index){
    return l->data[index-1];
}
void initGraph(Graph *g){
    g->n=n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            g->matrix[i][j]=0;
        }
    }
}
void addEdge(Graph *g, int x, int y){
    g->matrix[x][y]=1;
}
bool adjacent(Graph *g, int x, int y){
    return g->matrix[x][y]==1;
}
List neighbors(Graph *g, int x){
    List L;
    makenullList(&L);
    for(int i=1;i<=n;i++){
        if(adjacent(g,x,i)){
            pushList(&L,i);
        }
    }
    return L;
}
int mark[maxv];
int parent[maxv];
List BFS(Graph *g, int x){
    List rs; 
    makenullList(&rs);
    Queue q; 
    makenullQueue(&q);
    pushQueue(&q,x);
    while(!emptyQueue(&q)){
        int u = getQueue(&q);
        plusFront(&q);
        if(mark[u]==1) continue; 
        pushList(&rs,u); 
        mark[u]=1; 
        List L = neighbors(g,u); 
        for(int j=1;j<=L.size;j++){
            int v = getList(&L,j);
            if(mark[v]==0){ 
                pushQueue(&q,v); 
                if(parent[v]==-1){
                    parent[v]=u;
                }
            }
        }
    }
    return rs;
}
int main(){ 
    Graph g;
    scanf("%d%d",&n,&m);
    initGraph(&g);
    int u,v;
    for(int e=1;e<=m;e++){
        scanf("%d%d",&u,&v);
        addEdge(&g,u,v);
    }
    for(int i=1;i<=n;i++){
        mark[i]=0;
        parent[i]=-1;
    } 
    for(int i=1;i<=n;i++){
        if(mark[i]==0){ 
            List L = BFS(&g,i); 
            for(int j=1;j<=L.size;j++){
                int v = getList(&L,j);
                mark[v]=1;
            }
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d %d\n",i,parent[i]); 
    return 0;
}

//CONNECTED
int connected (Graph *pG){
    for(int i = 1; i <= pG->n; i++){
        mark[i] = 0;
    }
    bfs(pG, 1);
    for (int i = 1; i <= pG->n; i++)
        if (!mark[i])
            return 0;
    return 1;
}

//
#include <stdio.h>
#define MAX_N 100
typedef struct {
    int data[MAX_N];
    int size;
} Stack;
typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;
void make_null_stack(Stack *stack) {
    stack->size = 0;
}
void push(Stack *stack, int x) {
    stack->data[stack->size] = x;
    stack->size++;
}
int pop(Stack *stack) {
    stack->size--;
    return stack->data[stack->size];
}
void init_graph(Graph *pG, int n) {
    pG->n = n;
    pG->m = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            pG->A[i][j] = 0;
}
void add_edge(Graph *pG, int u, int v) {
    pG->A[u][v] = 1;
    pG->A[v][u] = 1;
    pG->m++;
}
void read_graph(Graph *pG) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(pG, n);
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(pG, u, v);
    }
}
int mark[MAX_N];
void init_mark(int n) {
    for (int i = 1; i <= n; i++) {
        mark[i] = 0;
    }
}
int dfs(Graph *pG, int s) {
    Stack S;
    make_null_stack(&S);
    push(&S, s);

    int nodes_count = 0;

    while (S.size > 0) {
        int u = pop(&S);
        if (!mark[u]) {
            mark[u] = 1;
            nodes_count++;
            for (int v = pG->n; v >= 1; v--) {
                if (pG->A[u][v] && !mark[v]) {
                    push(&S, v);
                }
            }
        }
    }
    return nodes_count;
}
int main() {
    Graph G;
    read_graph(&G);
    init_mark(G.n);
    int max = 0;
    for(int i = 1; i <= G.n; i++){
        int nodes = dfs(&G, i);
        if (nodes > max)
            max = nodes;
    }
    printf("%d", max);
    return 0;
}

//đảo/Tôn Ngộ Không
#include <stdio.h>
#define MAX_N 100
typedef struct{
	int n, m;
	int A[MAX_N][MAX_N];
} Graph;
void init_graph (Graph *pG, int n){
	pG->n = n;
	pG->m = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; i <= n; i++)
			pG->A[i][j] = 0;
}
void add_edge (Graph *pG, int u, int v) {
	pG->A[u][v] = 1;
    pG->A[v][u] = 1;
	pG->m++;
}
void read_graph (Graph *pG){
    int n, m;
    scanf ("%d %d", &n, &m);
    init_graph (pG, n);
    for (int i = 0; i < m; i++){
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(pG, u, v);
    }
}
int mark[MAX_N];
void init_mark (int n){
    for(int i = 1; i <= n; i++){
        mark[i] = 0;
    }
}
void dfs (Graph *pG, int u){
    if (!mark[u]){
        mark[u] = 1;
        for (int v = 1; v <= pG->n; v++){
            if(pG->A[u][v]){                    
                dfs(pG, v);
            }
        }
    }
}
int connected (Graph *pG){
    for(int i = 1; i <= pG->n; i++){
        mark[i] = 0;
    }
    dfs(pG, 1);
    for (int i = 1; i <= pG->n; i++)
        if (!mark[i])
            return 0;
    return 1;
}
int main (){
    Graph G;    
    read_graph (&G);
    init_mark(G.n);
     printf(connected(&G) ? "YES" : "NO");
}

//Microsoft Excel
#include <stdio.h>
#include <stdlib.h>
#define MAX_N 1000
int n, m;
int adj[MAX_N][MAX_N];
int visited[MAX_N];
int dfs(int u) {
    visited[u] = 1;
    for (int v = 0; v < n; v++) {
        if (adj[u][v]) {
            if (visited[v] == 1) {
                return 1;
            }
            if (visited[v] == 0 && dfs(v)) {
                return 1;
            }
        }
    }
    visited[u] = 2;
    return 0;
}
int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            adj[i][j] = 0;
        }
    }
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        adj[u-1][v-1] = 1;
    }
    for (int i = 0; i < n; i++) {
        visited[i] = 0;
    }
    for (int i = 0; i < n; i++) {
        if (visited[i] == 0) {
            if (dfs(i)) {
                printf("CIRCULAR REFERENCE\n");
                return 0;
            }
        }
    }
    printf("OK\n");
    return 0;
}

//Haddock 
#include <stdio.h>
#include <stdbool.h>
#define maxv 50
#define idx 100
int mark[maxv];
int index;
typedef int Vertices;
int n,m;
typedef struct{
    int matrix[maxv][maxv];
    Vertices n;
}Graph;
typedef struct{
    int data[idx];
    int size;
}List;
void makenullList(List *l){
    l->size=0;
}
void pushList(List *l, int element){
    l->data[l->size]=element;
    l->size++;
}
int getList(List *l, int index){
    return l->data[index];
}
void initGraph(Graph *g){
    g->n=n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            g->matrix[i][j]=0;
        }
    }
}
void addGraph(Graph *g, int x, int y){
    g->matrix[x][y]=1;
}
List neighbors(Graph *g, int x){
    List L;
    makenullList(&L);
    for(int i=1;i<=n;i++){
        if(g->matrix[x][i]==1){
            pushList(&L,i);
        }
    }
    return L;
}
void dfs(Graph* G, int x) {
    if(mark[x]==2) return;
    mark[x] = 2;
    List L = neighbors(G, x);
    for(int j=0;j<L.size;j++){
        int v = getList(&L, j);
        if(mark[v] == 2){
            index = 1; 
            return;
        }
        dfs(G, v);
    }
    mark[x]=1;
}
int check(Graph* G) {
    for(int i=1;i<=G->n;i++){
        mark[i] = 0;
    }
    index = 0;
    for(int j=1;j<=G->n;j++){
        dfs(G, j);    
    }
    return index;
}
int main(){
    Graph g;
    scanf("%d%d",&n,&m);
    initGraph(&g);
    int u,v;
    for(int i=1;i<=n;i++){
        scanf("%d%d",&u,&v);
        addGraph(&g,u,v);
    }
    if (check(&g)==1) printf("NO");
    else printf("YES");
    return 0;
}


//đồ thị phân đôi
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define MAX_N 1000
int n, m;
int adj[MAX_N][MAX_N];
int color[MAX_N];
bool bfs(int start) {
    int queue[MAX_N], front = 0, rear = 0;
    queue[rear++] = start;
    color[start] = 0;
    while (front < rear) {
        int u = queue[front++];
        for (int v = 0; v < n; v++) {
            if (adj[u][v]) {
                if (color[v] == -1) {
                    color[v] = 1 - color[u];
                    queue[rear++] = v;
                } else if (color[v] == color[u]) {
                    return false;
                }
            }
        }
    }
    return true;
}
bool isBipartite() {
    for (int i = 0; i < n; i++) {
        color[i] = -1;
    }
    for (int i = 0; i < n; i++) {
        if (color[i] == -1) {
            if (!bfs(i)) {
                return false;
            }
        }
    }
    return true;
}
int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            adj[i][j] = 0;
        }
    }
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        u--; v--;
        adj[u][v] = 1;
        adj[v][u] = 1;
    }
    if (isBipartite()) {
        printf("YES\n");
    } else {
        printf("NO\n");
    }
    return 0;
}

//Tarjan
#include <stdio.h>
#include <stdlib.h>
#define MAX_N 100
typedef struct {
    int data[MAX_N];
    int size;
} Stack;
void make_null_stack(Stack *S) {
    S->size = 0;
}
void push(Stack *S, int x) {
    S->data[S->size++] = x;
}
int pop(Stack *S) {
    return S->data[--S->size];
}
typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;
void init_graph(Graph *pG, int n) {
    pG->n = n;
    pG->m = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) // Sửa lỗi vòng lặp
            pG->A[i][j] = 0;
}
void add_edge(Graph *pG, int u, int v) {
    pG->A[u][v] = 1;
    pG->m++;
}
void read_graph(Graph *pG) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(pG, n);
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(pG, u, v);
    }
}
int num[MAX_N], min_num[MAX_N], on_stack[MAX_N], k = 1;
Stack S;
int min(int a, int b) { return a < b ? a : b; }
void SCC(Graph *pG, int u) {
    num[u] = min_num[u] = k++;
    push(&S, u);
    on_stack[u] = 1;
    for (int v = 1; v <= pG->n; v++) {
        if (pG->A[u][v]) {
            if (num[v] == -1) { // Kiểm tra đỉnh chưa duyệt
                SCC(pG, v);
                min_num[u] = min(min_num[u], min_num[v]);
            } else if (on_stack[v]) {
                min_num[u] = min(min_num[u], num[v]);
            }
        }
    }
    if (num[u] == min_num[u]) {
        int x;
        do {
            x = pop(&S);
            on_stack[x] = 0;
        } while (x != u);
    }
}
int main() {
    Graph G;
    read_graph(&G);
    make_null_stack(&S);
    for (int i = 1; i <= G.n; i++) {
        num[i] = -1;
        on_stack[i] = 0;
    }
    for (int i = 1; i <= G.n; i++) {
        if (num[i] == -1) SCC(&G, i);
    }
    for (int i = 1; i <= G.n; i++) {
        printf("%d %d\n", num[i], min_num[i]);
    }
    return 0;
}


//bộ phận liên thông
#include <stdio.h>
#define MAX_N 100
typedef struct {
    int data[MAX_N];
    int size;
} Stack;
typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;
void make_null_stack(Stack *stack) {
    stack->size = 0;
}
void push(Stack *stack, int x) {
    stack->data[stack->size] = x;
    stack->size++;
}
int pop(Stack *stack) {
    stack->size--;
    return stack->data[stack->size];
}
void init_graph(Graph *pG, int n) {
    pG->n = n;
    pG->m = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            pG->A[i][j] = 0;
}
void add_edge(Graph *pG, int u, int v) {
    pG->A[u][v] = 1;
    pG->A[v][u] = 1;
    pG->m++;
}
void read_graph(Graph *pG) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(pG, n);
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        add_edge(pG, u, v);
    }
}
int mark[MAX_N];
void init_mark(int n) {
    for (int i = 1; i <= n; i++) {
        mark[i] = 0;
    }
}
int dfs(Graph *pG, int s) {
    Stack S;
    make_null_stack(&S);
    push(&S, s);
    int nodes_count = 0;
    while (S.size > 0) {
        int u = pop(&S);
        if (!mark[u]) {
            mark[u] = 1;
            nodes_count++;
            for (int v = pG->n; v >= 1; v--) {
                if (pG->A[u][v] && !mark[v]) {
                    push(&S, v);
                }
            }
        }
    }
    return nodes_count;
}
int main() {
    Graph G;
    read_graph(&G);
    init_mark(G.n);

//đếm số bộ phận liên thông của đồ thị.
int connected_comps = 0;
    for (int i = 1; i <= G.n; i++){
        if(!mark[i]){
            dfs(&G, i);
            connected_comps++;
        }
    }    
    printf("%d", connected_comps);

//đếm số đỉnh của bộ phận liên thông của đỉnh 1.
    printf("%d", dfs(&G,1));

//đếm số đỉnh của bộ phận liên thông của đỉnh s. Đỉnh s được đọc từ bàn phím.
    int s;
    scanf("%d", &s);
    printf("%d", dfs(&G,s));

//tìm bộ phận liên thông có nhiều đỉnh nhất.
    int max = 0;
    for(int i = 1; i <= G.n; i++){
        int nodes = dfs(&G, i);
        if (nodes > max)
            max = nodes;
    }
    printf("%d", max);
    return 0;
}


//CIRCLED
#include <stdio.h>
#include <stdbool.h>
#define MAX_V 100
typedef struct {
    int n;
    int m;
    int matrix[MAX_V][MAX_V];
} Graph;
void initGraph(Graph *g, int n) {
    g->n = n;
    g->m = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            g->matrix[i][j] = 0;
        }
    }
}
void addEdge(Graph *g, int u, int v) {
    g->matrix[u][v] = 1;
}
bool hasCycle(Graph *g, int u, bool visited[], bool recursionStack[]) {
    if (!visited[u]) {
        visited[u] = true;
        recursionStack[u] = true;
        for (int v = 0; v < g->n; v++) {
            if (g->matrix[u][v]) {
                if (!visited[v] && hasCycle(g, v, visited, recursionStack)) {
                    return true;
                } else if (recursionStack[v]) {
                    return true;
                }
            }
        }
    }
    recursionStack[u] = false;
    return false;
}
bool detectCycle(Graph *g) {
    bool visited[MAX_V] = {false};
    bool recursionStack[MAX_V] = {false};
    for (int i = 0; i < g->n; i++) {
        if (!visited[i]) {
            if (hasCycle(g, i, visited, recursionStack)) {
                return true;
            }
        }
    }
    return false;
}
int main() {
    Graph g;
    int n, m;
    scanf("%d %d", &n, &m);
    initGraph(&g, n);
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(&g, u - 1, v - 1);
    }
    if (detectCycle(&g)) {
        printf("CIRCLED\n");
    } else {
        printf("NO CIRCLE\n");
    }
    return 0;
}

//Chu trình hợp lệ
#include <stdio.h>
#include <stdbool.h>
#define MAX_V 100
typedef struct {
    int n;
    int m;
    int matrix[MAX_V][MAX_V];
} Graph;

void initGraph(Graph *g, int n) {
    g->n = n;
    g->m = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            g->matrix[i][j] = 0;
        }
    }
}

void addEdge(Graph *g, int u, int v) {
    g->matrix[u][v] = 1;
}

bool dfs(Graph *g, int u, bool visited[], bool recursionStack[], int parent[], int *cycleStart, int *cycleEnd) {
    visited[u] = true;
    recursionStack[u] = true;

    for (int v = 0; v < g->n; v++) {
        if (g->matrix[u][v]) {
            if (!visited[v]) {
                parent[v] = u;
                if (dfs(g, v, visited, recursionStack, parent, cycleStart, cycleEnd)) {
                    return true;
                }
            } else if (recursionStack[v]) {
                *cycleStart = v;
                *cycleEnd = u;
                return true;
            }
        }
    }

    recursionStack[u] = false;
    return false;
}

void findCycle(Graph *g) {
    bool visited[MAX_V] = {false};
    bool recursionStack[MAX_V] = {false};
    int parent[MAX_V] = {-1};
    int cycleStart = -1, cycleEnd = -1;

    for (int i = 0; i < g->n; i++) {
        if (!visited[i]) {
            if (dfs(g, i, visited, recursionStack, parent, &cycleStart, &cycleEnd)) {
                break;
            }
        }
    }

    if (cycleStart == -1) {
        printf("-1\n");
    } else {
        int current = cycleEnd;
        int cycle[MAX_V];
        int cycleSize = 0;

        cycle[cycleSize++] = cycleStart;
        while (current != cycleStart) {
            cycle[cycleSize++] = current;
            current = parent[current];
        }
        cycle[cycleSize++] = cycleStart;

        for (int i = cycleSize - 1; i >= 0; i--) {
            printf("%d ", cycle[i] + 1);
        }
        printf("\n");
    }
}
int main() {
    Graph g;
    int n, m;
    scanf("%d %d", &n, &m);
    initGraph(&g, n);
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(&g, u - 1, v - 1);
    }
    findCycle(&g);
    return 0;
}

//Moore 	
#include <stdio.h>

#define MAX_N 100
#define NO_EDGE -1
#define oo 1e9

typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;

void init_graph(Graph *G, int n){
    G->n = n;
    G->m =0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            G->A[i][j] = NO_EDGE;
        }
    }
}

void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->m++;
}

void read_graph(Graph *G) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i < m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }    
}

int mark[MAX_N], p[MAX_N], pi[MAX_N];

void dijkstra(Graph *G, int u){
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[u] = 0;
    p[u] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for (int v = 1; v <= G->n; v++){
            if (G->A[u][v] != NO_EDGE && !mark[v] && pi[u] + G->A[u][v] < pi[v]) {
                pi[v] = pi[u] + G->A[u][v]; 
                p[v] = u;
            }
        }
        mark[u] = 1;
        int min_pi = oo;        
        for (int j = 1; j <= G->n; j++){
            if (!mark[j] && pi[j] < min_pi) {
                min_pi = pi[j];
                u = j;
            }
        }        
    }
}

int main(){
    Graph G;
    read_graph(&G);    
    dijkstra(&G, 1);
    for(int i = 1; i <= G.n; i++){
        printf("pi[%d] = %d, p[%d] = %d\n", i, pi[i], i, p[i]);
    }
}

// chiều dài đường đi ngắn nhất
#include <stdio.h>

#define MAX_N 100
#define NO_EDGE -1
#define oo 1e9

typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;

void init_graph(Graph *G, int n){
    G->n = n;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            G->A[i][j] = NO_EDGE;
        }
    }
}

void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->m++;
}

void read_graph(Graph *G) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i < m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }    
}

int mark[MAX_N], p[MAX_N], pi[MAX_N];

void dijkstra(Graph *G, int u){
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[u] = 0;
    p[u] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for (int v = 1; v <= G->n; v++){
            if (G->A[u][v] != NO_EDGE && !mark[v] && pi[u] + G->A[u][v] < pi[v]) {
                pi[v] = pi[u] + G->A[u][v]; 
                p[v] = u;
            }
        }
        mark[u] = 1;
        int min_pi = oo;        
        for (int j = 1; j <= G->n; j++){
            if (!mark[j] && pi[j] < min_pi) {
                min_pi = pi[j];
                u = j;
            }
        }        
    }
}

int main(){
    Graph G;
    read_graph(&G);    
    dijkstra(&G, 1);
    if(pi[G.n] != oo) printf("%d", pi[G.n]); 
    else printf("-1");
}



//đường đi ngắn nhất từ đỉnh s đến đỉnh t
#include <stdio.h>
#define MAX_N 100
#define NO_EDGE -1
#define oo 1e9
typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;
void init_graph(Graph *G, int n){
    G->n = n;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            G->A[i][j] = NO_EDGE;
        }
    }
}
void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->A[v][u] = w; 
    G->m++;
}
void read_graph(Graph *G) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i < m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }
}
int mark[MAX_N], p[MAX_N], pi[MAX_N];
void dijkstra(Graph *G, int u){    
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[u] = 0;
    p[u] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for (int v = 1; v <= G->n; v++){
            if (G->A[u][v] != NO_EDGE && !mark[v] && pi[u] + G->A[u][v] < pi[v]) {
                pi[v] = pi[u] + G->A[u][v]; 
                p[v] = u;
            }
        }
        mark[u] = 1;
        int min_pi = oo;        
        for (int j = 1; j <= G->n; j++){
            if (!mark[j] && pi[j] < min_pi) {
                min_pi = pi[j];
                u = j;
            }
        }        
    }
}
void print_path(int s, int t){
    int i = 0, path[MAX_N];
    while(t != s){
        path[i++] = t;        
        t = p[t];
    }
    path[i] = s;
    for(int j = i; j > 0; j--){
        printf("%d -> ", path[j]);
    }
    printf("%d", path[0]);
}
int main(){
    Graph G;
    read_graph(&G);
    int s, t;
    scanf("%d %d", &s, &t);
    dijkstra(&G, s);
    print_path(s, t);
}



//Mê cung số (number maze)
#include <stdio.h>
#define MAX_N 100
#define NO_EDGE -1
#define oo 1e9
typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;
void init_graph (Graph *G, int n){
    G->n = n;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            G->A[i][j] = NO_EDGE;
        }
    }
}
void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->m++;
}
int is_valid(int i, int j, int n, int m){
    return (0 <= i && i < n && j >= 0 && j < m);
}
void read_graph(Graph *G){
    int n, m, w;
    scanf("%d %d", &n, &m);
    init_graph(G, n*m);
    int adj[][4]={{-1, 1,  0, 0},
                  { 0, 0, -1, 1}};
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            scanf("%d", &w);
            for(int k = 0; k < 4; k++){
                int adjR = i + adj[0][k];
                int adjC = j + adj[1][k];                
                if(is_valid(adjR, adjC, n, m)){                    
                    add_edge(G, adjR*m+adjC+1, i*m+j+1, w);
                }                
            }
        }
    }
}
int mark[MAX_N], pi[MAX_N], p[MAX_N];

void dijkstra(Graph *G, int u){    
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[u] = 0;
    p[u] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for(int v = 1; v <= G->n; v++){
            if (G->A[u][v] != NO_EDGE && !mark[v] && pi[u] + G->A[u][v] < pi[v]) {
                pi[v] = pi[u] + G->A[u][v]; 
                p[v] = u;
            }
        }
        mark[u] = 1;
        int min_pi = oo;        
        for (int j = 1; j <= G->n; j++){
            if (!mark[j] && pi[j] < min_pi) {
                min_pi = pi[j];
                u = j;
            }
        }        
    }
}  
int main(){
    Graph G;
    read_graph(&G);
    dijkstra(&G, 1);
    printf("%d", pi[G.n]);
}





// đơn đồ thị có hướng, có trọng số (có thể âm)
#include <stdio.h>
#define MAX_N 100
#define MAX_M 500
#define NO_EDGE -1
#define oo 1e9
typedef struct {
    int u, v, w;
} Edge;
typedef struct {
    int n, m;
    Edge edges[MAX_M];
} Graph;
void init_graph(Graph *G, int n){
    G->n = n;
    G->m = 0;
}
void add_edge(Graph *G, int u, int v, int w){
    G->edges[G->m].u = u;
    G->edges[G->m].v = v;
    G->edges[G->m].w = w;
    G->m++;
}
void read_graph(Graph *G) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i < m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }    
}
int mark[MAX_N], p[MAX_N], pi[MAX_N];
void bellman_ford(Graph *G, int s){
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[s] = 0;
    p[s] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for (int j = 0; j < G->m; j++){
            Edge e = G->edges[j];
            if(pi[e.u] != oo && pi[e.u] + e.w < pi[e.v]){
                pi[e.v] = pi[e.u] + e.w;
                p[e.v] = e.u;
            }
        }
    }
}
void print_length(Graph *G){
    bellman_ford(G, 1);
    pi[G->n] != oo ? printf("%d", pi[G->n]) : printf("-1");
}

void print_path(Graph *G){
    int s, t;
    scanf("%d %d", &s, &t);
    bellman_ford(G, s);
    int i = 0, path[MAX_N];
    while(t != s){
        path[i++] = t;        
        t = p[t];
    }
    path[i] = s;
    for(int j = i; j > 0; j--){
        printf("%d -> ", path[j]);
    }
    printf("%d", path[0]);
}
int main(){
    Graph G;
    read_graph(&G);   
    print_length(&G);
print_path(&G);
}







#include <stdio.h>

#define MAX_N 100
#define MAX_M 500
#define NO_EDGE -1
#define oo 1e9

typedef struct {
    int u, v, w;
} Edge;

typedef struct {
    int n, m;
    Edge edges[MAX_M];
} Graph;

void init_graph(Graph *G, int n){
    G->n = n;
    G->m = 0;
}

void add_edge(Graph *G, int u, int v, int w){
    G->edges[G->m].u = u;
    G->edges[G->m].v = v;
    G->edges[G->m].w = w;
    G->m++;
}
void read_graph(Graph *G) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i < m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }    
}
int mark[MAX_N], p[MAX_N], pi[MAX_N];
int bellman_ford(Graph *G, int s){
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[s] = 0;
    p[s] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for (int j = 0; j < G->m; j++){
            Edge e = G->edges[j];
            if(pi[e.u] != oo && pi[e.u] + e.w < pi[e.v]){
                pi[e.v] = pi[e.u] + e.w;
                p[e.v] = e.u;
            }
        }
    }
    for (int j = 0; j < G->m; j++){
        Edge e = G->edges[j];
        if(pi[e.u] != oo && pi[e.u] + e.w < pi[e.v]){
            return 1;
        }
    }
    return 0;
}
int main(){
    Graph G;
    read_graph(&G);
    int s;
    scanf("%d", &s);
    bellman_ford(&G, s) ? printf("YES") : printf("NO");
}



//Extended traffic 
#include <stdio.h>

#define MAX_N 100
#define MAX_M 500
#define NO_EDGE -1
#define oo 1e9

typedef struct {
    int u, v, w;
} Edge;

typedef struct {
    int n, m;
    Edge edges[MAX_M];
} Graph;

void init_graph(Graph *G, int n){
    G->n = n;
    G->m = 0;
}

void add_edge(Graph *G, int u, int v, int w){
    G->edges[G->m].u = u;
    G->edges[G->m].v = v;
    G->edges[G->m].w = w;
    G->m++;
}

void read_graph(Graph *G) {
    int n, m, b[MAX_N];
    scanf("%d %d", &n, &m);
    init_graph(G, n);    
    for(int i = 1; i <= n; i++){
        scanf("%d", &b[i]);
    }
    for(int i = 0; i < m; i++){
        int u, v;
        scanf("%d %d", &u, &v);
        int w = (b[v] - b[u]);
        w *= w*w;
        add_edge(G, u, v, w);
    }    
}

int mark[MAX_N], p[MAX_N], pi[MAX_N];

void bellman_ford(Graph *G, int s){
    for(int i = 1; i <= G->n; i++){
        mark[i] = 0;
        pi[i] = oo;
    }
    pi[s] = 0;
    p[s] = -1;
    for (int i = 1; i <= G->n - 1; i++) {
        for (int j = 0; j < G->m; j++){
            Edge e = G->edges[j];
            if(pi[e.u] != oo && pi[e.u] + e.w < pi[e.v]){
                pi[e.v] = pi[e.u] + e.w;
                p[e.v] = e.u;
            }
        }
    }
}

int main(){
    Graph G;
    read_graph(&G);
    int s, t;
    scanf("%d %d", &s, &t);
    bellman_ford(&G, 1);
    if (pi[t]!=oo) printf("%d", pi[t]); else printf("?");

}






//Floyd - Warshall 
#include <stdio.h>

#define MAX_N 100
#define NO_EDGE 0
#define oo 1e9

typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;

void init_graph(Graph *G, int n){
    G->n = n;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            G->A[i][j] = NO_EDGE;
        }
    }
}

void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->m++;
}

void read_graph(Graph *G) {
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);        
    for(int i = 0; i < m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }    
}

int pi[MAX_N][MAX_N], next[MAX_N][MAX_N];

int floyd_warshall(Graph *G){
    for(int i = 1; i <= G->n; i++){
        pi[i][i] = 0;
        for(int j = 1; j <= G->n; j++){
            if(G->A[i][j] != NO_EDGE){
                pi[i][j]   = G->A[i][j];
                next[i][j] = j;
            } else if(i != j){
                pi[i][j]   = oo;
                next[i][j] = -1;
            }
        }
    }
    for(int k = 1; k <= G->n; k++){
        for(int i = 1; i <= G->n; i++){
            for(int j = 1; j <= G->n; j++){
                if(pi[i][j] > pi[i][k] + pi[k][j]){
                    pi[i][j] = pi[i][k] + pi[k][j];
                    next[i][j] = next[i][k];
                }               
            }
        }
    }
    for (int i = 1; i <= G->n; i++){
        if (pi[i][i] < 0){
            return 1;
        }
    }
    return 0;  
}

int main(){
    Graph G;
    read_graph(&G);
    floyd_warshall(&G) ? printf("YES") : printf("NO");
}


//Viết chương trình đọc đồ thị vô hướng liên thông và tìm cây khung có trọng số nhỏ nhất bằng thuật toán Kruskal.
#include <stdio.h>
#define MAX_N 100
typedef struct {
    int u, v, w;
} Edge;
typedef struct {
    int n, m;
    Edge E[MAX_N];
} Graph;
void init_graph(Graph *G, int n){
    G->n = n;
    G->m = 0;
}
void add_edge(Graph *G, int u, int v, int w){
    Edge e = {u,v,w};
    G->E[G->m] = e;
    G->m++;
}
void read_graph(Graph *G){
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i <= m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }
}
int parent[MAX_N];
int find_root(int u) {
    while (parent[u] != u)
        u = parent[u];
    return u;
}

void sort(Edge e[], int m){
  for(int i = 0; i < m; i++){
      for(int j = i+1; j < m; j++){
          if(e[i].w > e[j].w){
              Edge x = e[i];
              e[i] = e[j];
              e[j] = x;
          }
      }
  }
}
int kruskal(Graph *G, Graph *T){
    sort(G->E, G->m);
    init_graph(T, G->n);
    for(int u = 1; u <= G->n; u++){
        parent[u] = u;
    }
    int sum_w = 0;
    for(int i = 0; i < G->m; i++){
        Edge e = G->E[i];
        int r_u = find_root(e.u);
        int r_v = find_root(e.v);
        if(r_u != r_v){
            if(e.u < e.v){
                add_edge(T, e.u, e.v, e.w);
                parent[r_v] = r_u;
            } else {
                add_edge(T, e.v, e.u, e.w);
                parent[r_u] = r_v;
            }
            sum_w += e.w;
        }
    }
    sort(T->E, T->m);
    return sum_w;
}
int main(){
    Graph G, T;
    read_graph(&G);
    printf("%d\n", kruskal(&G, &T));  
    for(int i = 0; i < T.m; i++){
        Edge e = T.E[i];
        printf("%d %d %d\n", e.u, e.v, e.w);
    }
}


//Viết chương trình đọc một đồ thị vô hướng liên thông và tìm cây khung có trọng số nhỏ nhất bằng thuật toán Prim.
#include <stdio.h>

#define MAX_N 100
#define NO_EDGE 0
#define oo 1e9

typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;

void init_graph(Graph *G, int n){
    G->n = n;
    for(int u = 1; u <= n; u++){
        for(int v = 1; v <= n; v++){
            G->A[u][v] = NO_EDGE;
        }
    }
}

void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->A[v][u] = w;
    G->m++;
}

void read_graph(Graph *G){
    int n, m;
    scanf("%d %d", &n, &m);
    init_graph(G, n);
    for(int i = 0; i <= m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }
}

int pi[MAX_N], p[MAX_N], mark[MAX_N];

int prim(Graph *G, Graph *T, int u){
    for(int i = 1; i <= G->n; i++){
        pi[i] = oo;
        p[i] = -1;
        mark[i] = 0;
    }
    pi[u] = 0;
    for(int i = 0; i < G->n-1; i++){        
        for(int v = 1; v <= G->n; v++){            
            if(G->A[u][v] != NO_EDGE && mark[v] == 0 && G->A[u][v] < pi[v]){
                pi[v] = G->A[u][v];
                p[v] = u;
            }
        }
        mark[u] = 1;
        printf("%d\n", u);
        int min_pi = oo;        
        for (int j = 1; j <= G->n; j++){
            if (!mark[j] && pi[j] < min_pi) {
                min_pi = pi[j];
                u = j;
            }                
        }
    }
    printf("%d\n", u);
    int sum_w = 0;
    init_graph(T, G->n);
    for(int u = 1; u <= G->n; u++){
        if (p[u] != -1){
            add_edge(T, p[u], u, G->A[p[u]][u]);
            sum_w += G->A[p[u]][u];
        }
    }
    return sum_w;
}

int delete_edge(Graph *G, Graph *T) {
    int sum = 0;

    for (int u = 1; u <= G->n; u++) { 
        for (int v = u + 1; v <= G->n; v++) {
            if (G->A[u][v] != NO_EDGE)
                sum += G->A[u][v];
        }
    }
    int sum_prim = prim(G, T, 1);
    return sum - sum_prim;
}
int main(){
    Graph G, T;
    read_graph(&G);
    prim(&G, &T, 1);
}

//Ngưu Lang
#include <stdio.h>
#define MAX_N 100
#define NO_EDGE 0
#define oo 1e9
typedef struct {
    int n, m;
    int A[MAX_N][MAX_N];
} Graph;
void init_graph(Graph *G, int n){
    G->n = n;
    for(int u = 1; u <= n; u++){
        for(int v = 1; v <= n; v++){
            G->A[u][v] = NO_EDGE;
        }
    }
}
void add_edge(Graph *G, int u, int v, int w){
    G->A[u][v] = w;
    G->A[v][u] = w;
    G->m++;
}
void read_graph(Graph *G, int *k){
    int n, m;
    scanf("%d %d %d", &n, &m, k);
    init_graph(G, n);
    for(int i = 0; i <= m; i++){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add_edge(G, u, v, w);
    }
//Hoàng là thợ điện
    for( i = 0; i <= m; i++){
        int u, v, s, d;
        scanf("%d %d %d %d", &u, &v, &s, &d);
        add_edge(G, u, v, s*d);
    }
}

int pi[MAX_N], p[MAX_N], mark[MAX_N];
int prim(Graph *G, Graph *T, int u){
    for(int i = 1; i <= G->n; i++){
        pi[i] = oo;
        p[i] = -1;
        mark[i] = 0;
    }
    pi[u] = 0;
    for(int i = 0; i < G->n-1; i++){        
        for(int v = 1; v <= G->n; v++){            
            if(G->A[u][v] != NO_EDGE && mark[v] == 0 && G->A[u][v] < pi[v]){
                pi[v] = G->A[u][v];
                p[v] = u;
            }
        }
        mark[u] = 1;
        int min_pi = oo;        
        for (int j = 1; j <= G->n; j++){
            if (!mark[j] && pi[j] < min_pi) {
                min_pi = pi[j];
                u = j;
            }                
        }
    }
    int sum_w = 0;
    init_graph(T, G->n);
    for(int u = 1; u <= G->n; u++){
        if (p[u] != -1){
            add_edge(T, p[u], u, G->A[p[u]][u]);
            sum_w += G->A[p[u]][u];
        }
    }
    return sum_w;
}
int main(){
    Graph G, T;
    int k;
    read_graph(&G, &k);
    k = prim(&G, &T, 1) - k;
    k == 0 ? printf("OK") : printf("%d", k);
}
