...
void selection(record a[], int n){
	int i, j, lowindex;
	keytype lowkey;
	for(i=0; i<=n-2; i++){
		lowindex = i;
		lowkey = a[i].key;
		for(j = i+1; j<n-1; j++){
			if(a[j].key < lowkey){
				lowkey = a[j].key;
				lowindex = j;
			}
		}
		swap(&a[i], &a[lowindex]);
	}
}

void insertion(record a[], int n){
	int i, j;
	for(i=1; i<n; i++){
		j=i;
		while((j>0)&&(a[j].key< a[j-1].key)){
			swap(&a[j], &a[j-1]);
			j--;
		}
	}
}

void bubble(record a[], int n){
	for(int i=0; i<n; i++){
		for(int j=n-1; j>i+1; j--)
			if(a[i].key> a[j].key)
				swap(&a[i], &a[j]);
	}
}

int findpivot(record a[], int i, int j){
	keytype firstkey = a[i].key;
	int k = i+1;
	while((k<=j) && (a[k].key == firstkey)) k++;
	if(k>j) return -1;
	else 
		if(a[k].key>firstkey) return k; else return i;
}

int partition(record a[], int L, int R, keytype pivot){
	while(L<=R){
		while(a[L].key < pivot)
			L++;
		while(a[R].key >= pivot)
			R--;
		if(L < R)
			swap(&a[L], &a[R]);
	}
	return L;
}

void quick_sort(record a[], int i, int j){
	int pivotidx = findpivot(a, i, j);
	if(pivotidx != -1){
		int k = partition(a, i, j, a[pivotidx].key);
		quick_sort(a, i, k-1);
		quick_sort(a,k, j);
	}
	
}
void pushdow(record a[], int first, int last){
	int r = first;
	while(r <= (last-1)/2){
		if(last == r*2+1){
			if(a[r].key > a[last].key) swap(&a[r], &a[last]);
			r= last;
		}else
		if((a[r].key > a[r*2+1].key)&&(a[r*2+1].key<= a[r*2+2].key)){
			swap(&a[r], &a[r*2+1]);
			r = r*2+1;
		}else
		if((a[r].key> a[r*2+2].key)&&(a[r*2+2].key< a[r*2+1].key)){
			swap(&a[r], &a[r*2+2]);
			r = r*2+2;
		}else r= last;
	}
}
void heap_sort(record a[], int n){
	int i;
	for(i=(n-2)/2; i>=0; i--){
		pushdow(a, i, n-1);
	}
	for(i=n-1; i>=2; i--){
		swap(&a[0], &a[i]);
		pushdow(a,0, i-1);	
	}
	swap(&a[0], &a[1]);
}

void solve(item *a, int n, int p_val, int m, int x[], int i, float *final_res){
	for(int j = m/a[i].w; j >= 0; j--){
		float cur_val, remain, ubound;
		cur_val= p_val + j*a[i].v;
		remain = m - j*a[i].w;
		ubound = cur_val + remain*a[i+1].ppu;
		if(ubound > *final_res){
			x[i] = j;			
			if((i == n-1 || remain == 0) && cur_val > *final_res){
				*final_res = cur_val;
				for(int k = 0; k < n; k++){
					a[k].qty = x[k];
				}		
			}
			else
				solve(a, n, cur_val, remain, x, i+1, final_res);
		}		
		x[i] = 0;	
	}
}
