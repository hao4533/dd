...
void selection(record a[], int n){
	int i, j, lowindex;
	keytype lowkey;
	for(i=0; i<=n-2; i++){
		lowindex = i;
		lowkey = a[i].key;
		for(j = i+1; j<n-1; j++){
			if(a[j].key < lowkey){
				lowkey = a[j].key;
				lowindex = j;
			}
		}
		swap(&a[i], &a[lowindex]);
	}
}

void insertion(record a[], int n){
	int i, j;
	for(i=1; i<n; i++){
		j=i;
		while((j>0)&&(a[j].key< a[j-1].key)){
			swap(&a[j], &a[j-1]);
			j--;
		}
	}
}

void bubble(record a[], int n){
	for(int i=0; i<n; i++){
		for(int j=n-1; j>i+1; j--)
			if(a[i].key> a[j].key)
				swap(&a[i], &a[j]);
	}
}

int findpivot(record a[], int i, int j){
	keytype firstkey = a[i].key;
	int k = i+1;
	while((k<=j) && (a[k].key == firstkey)) k++;
	if(k>j) return -1;
	else 
		if(a[k].key>firstkey) return k; else return i;
}

int partition(record a[], int L, int R, keytype pivot){
	while(L<=R){
		while(a[L].key < pivot)
			L++;
		while(a[R].key >= pivot)
			R--;
		if(L < R)
			swap(&a[L], &a[R]);
	}
	return L;
}

void quick_sort(record a[], int i, int j){
	int pivotidx = findpivot(a, i, j);
	if(pivotidx != -1){
		int k = partition(a, i, j, a[pivotidx].key);
		quick_sort(a, i, k-1);
		quick_sort(a,k, j);
	}
	
}
void pushdow(record a[], int first, int last){
	int r = first;
	while(r <= (last-1)/2){
		if(last == r*2+1){
			if(a[r].key > a[last].key) swap(&a[r], &a[last]);
			r= last;
		}else
		if((a[r].key > a[r*2+1].key)&&(a[r*2+1].key<= a[r*2+2].key)){
			swap(&a[r], &a[r*2+1]);
			r = r*2+1;
		}else
		if((a[r].key> a[r*2+2].key)&&(a[r*2+2].key< a[r*2+1].key)){
			swap(&a[r], &a[r*2+2]);
			r = r*2+2;
		}else r= last;
	}
}
void heap_sort(record a[], int n){
	int i;
	for(i=(n-2)/2; i>=0; i--){
		pushdow(a, i, n-1);
	}
	for(i=n-1; i>=2; i--){
		swap(&a[0], &a[i]);
		pushdow(a,0, i-1);	
	}
	swap(&a[0], &a[1]);
}
